from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from keyboard.inline import *
from aiogram.fsm.context import FSMContext
from aiogram.types import FSInputFile
from db import *
from db.xls import *
from strategy_logic.get_all_coins import get_usdt_pairs
import datetime
import asyncio

from basic.state import *
from config import config

router = Router()


def interval_weight(interval):
    weights = {'1d': 4, '4h': 3, '1h': 2, '30m': 1}
    return weights.get(interval, 0)  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º 0, –µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω


def split_text_to_chunks(text, chunk_size=4096):
    chunks = []
    while text:
        if len(text) <= chunk_size:
            chunks.append(text)  # –ï—Å–ª–∏ –æ—Å—Ç–∞–≤—à–∏–π—Å—è —Ç–µ–∫—Å—Ç –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω chunk_size
            break
        # –ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏
        chunk = text[:chunk_size]
        if '\n' in chunk:
            chunk = chunk.rsplit('\n', 1)[0]
        chunks.append(chunk)
        text = text[len(chunk):]  # –û—Å—Ç–∞–≤—à–∞—è—Å—è —á–∞—Å—Ç—å —Ç–µ–∫—Å—Ç–∞
    return chunks


def interval_conv(interval):
    if interval == '1D':
        return '1–î'
    elif interval == '4H':
        return '4h'
    elif interval == '1H':
        return '1h'
    elif interval == '30':
        return '30m'
    
def buy_sale(status, interval):
    if status == 'buy':
        return f'üî∞{interval} - B;'
    else:
        return f"üîª{interval} - S;"

def interval_conv(interval):
    if interval == '1D':
        return '1–î'
    elif interval == '4H':
        return '4h'
    elif interval == '1H':
        return '1h'
    elif interval == '30':
        return '30m'
    return interval

def interval_weight(interval):
    weights = {'1D': 4, '4H': 3, '1H': 2, '30': 1}
    return weights.get(interval, 0)

def buy_sale(status, interval):
    if status == 'buy':
        return f'üî∞{interval} - B;'
    else:
        return f'üîª{interval} - S;'


async def format_monitor_signals(callback, user, mes=None):
    forms = await get_signals()
    monitor_pairs = user.get('monitor_pairs', '')  # –ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É
    print(monitor_pairs)
    if not monitor_pairs:  # –ï—Å–ª–∏ –Ω–µ—Ç –ø–∞—Ä, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        if mes is None:
            pass
            await callback.message.edit_text(
                text="–£ –≤–∞—Å –Ω–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.",
                reply_markup=monitor_inline()
            )

        return

    monitor_pairs = monitor_pairs.split(',')  # –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞ —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ –∏–∑–±—Ä–∞–Ω–Ω—ã–º –ø–∞—Ä–∞–º
    filtered_signals = [form for form in forms if form['symbol'] in monitor_pairs]
    print(filtered_signals)
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã
    grouped_signals = {}
    for form in filtered_signals:
        symbol = form['symbol']
        interval = form['interval']
        status = buy_sale(form['status'], interval_conv(interval))
        if symbol not in grouped_signals:
            grouped_signals[symbol] = []
        grouped_signals[symbol].append({'interval': interval, 'status': status})

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –≤–Ω—É—Ç—Ä–∏ –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
    for symbol in grouped_signals:
        grouped_signals[symbol].sort(key=lambda x: interval_weight(x['interval']), reverse=True)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    msg_parts = []
    for symbol, signals in grouped_signals.items():
        msg_parts.append(f"{symbol} - {''.join(signal['status'] for signal in signals)}")
    
    if not msg_parts:  # –ï—Å–ª–∏ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç
        msg = "–ù–∞ –≤–∞—à–∏—Ö –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞—Ö –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤."
    else:
        msg = "–°–∏–≥–Ω–∞–ª—ã –Ω–∞ –≤–∞—à–∏—Ö –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞—Ö:\n\n" + "\n".join(msg_parts)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    if mes is None:
        await callback.message.edit_text(
            text=msg,
            reply_markup=monitor_inline()
        )
    else:
        await callback.answer(
            text=msg,
            reply_markup=monitor_inline()
        )

@router.callback_query(F.data.startswith('sub_remove'))
async def process_subscription_removal(callback: CallbackQuery):
    data = callback.data.split()[0].split('_')  # –ù–∞–ø—Ä–∏–º–µ—Ä: "sub_remove_BTCUSDT_1D"
    symbol = data[2]
    interval = data[3]
    group = callback.data.split()[1]
    if group == 'True':
        user_id = config.trading_group_id
    else:
        user_id = callback.from_user.id

    await remove_subscription(user_id, symbol, interval)

    subscriptions = await get_user_subscriptions(user_id)

    if not subscriptions:
        kb = [
            [InlineKeyboardButton(text='–ù–∞–∑–∞–¥', callback_data='start')]
        ]
        await callback.message.edit_text("–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω—É –ø–∞—Ä—É.", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –∫–Ω–æ–ø–æ–∫
    buttons = []
    for sub in subscriptions:
        symbol = sub.get("symbol")  # –î–æ—Å—Ç–∞–µ–º –ø–æ –∫–ª—é—á—É
        interval = sub.get("interval")

        callback_data = f"sub_remove_{symbol}_{interval} {group}"
        button = InlineKeyboardButton(text=f"‚ùå {symbol} ({interval})", callback_data=callback_data)
        buttons.append([button])  # –ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

    buttons.append([InlineKeyboardButton(text='–ù–∞–∑–∞–¥', callback_data=f'sub start {group}')])
    # –°–æ–∑–¥–∞—ë–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏
    kb = InlineKeyboardMarkup(inline_keyboard=buttons)

    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
    await callback.answer(f"–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç {symbol} ({interval}).")

@router.message(lambda message: message.text and message.text.lower() == "id")
async def get_group_id_handler(message: Message):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏—à–ª–æ –∏–∑ –≥—Ä—É–ø–ø—ã –∏–ª–∏ —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã
    if message.chat.type in ["group", "supergroup"]:
        await message.reply(f"ID —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã: `{message.chat.id}`", parse_mode="Markdown")
    else:
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–µ –∏–ª–∏ —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø–µ.")


@router.callback_query(F.data.startswith('sub'))
async def subscribe(callback: CallbackQuery, state: FSMContext):
    action = callback.data.split()[1]
    if action == 'start':
        group = callback.data.split()[2]
        if group == 'True':
            user_id = config.trading_group_id
        else:
            user_id = callback.from_user.id
        subscriptions = await get_user_subscriptions(user_id)
        
        if not subscriptions:
            await callback.message.edit_text("–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω—É –ø–∞—Ä—É.", reply_markup=subscription_management_inline(group))
            return

        msg = "–í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —Å–ª–µ–¥—É—é—â–∏–º –ø–∞—Ä–∞–º:\n\n"
        for sub in subscriptions:
            symbol = sub.get("symbol")  # –î–æ—Å—Ç–∞–µ–º –ø–æ –∫–ª—é—á—É
            interval = sub.get("interval")

            msg += f"üîπ {symbol} (–¢–§ - {interval_conv(interval)})\n"
        
        await callback.message.edit_text(
            text=msg,
            reply_markup=subscription_management_inline(group)
        )

    elif action == 'add':
        group = callback.data.split()[2]
        msg = await callback.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞—Ä—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: BTCUSDT):", reply_markup=close_state())
        await state.set_state(SubscriptionStates.waiting_for_pair)
        await state.update_data(last_msg=msg.message_id, group=group)
    
    elif action == 'del':
        group = callback.data.split()[2]
        if group == 'True':
            user_id = config.trading_group_id
        else:
            user_id = callback.from_user.id

        
        subscriptions = await get_user_subscriptions(user_id)

        if not subscriptions:
            await callback.answer("–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω—É –ø–∞—Ä—É.")
            return

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ –∫–Ω–æ–ø–æ–∫
        buttons = []
        for sub in subscriptions:
            symbol = sub.get("symbol")  # –î–æ—Å—Ç–∞–µ–º –ø–æ –∫–ª—é—á—É
            interval = sub.get("interval")

            callback_data = f"sub_remove_{symbol}_{interval} {group}"
            button = InlineKeyboardButton(text=f"‚ùå {symbol} ({interval})", callback_data=callback_data)
            buttons.append([button])  # –ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

        buttons.append([InlineKeyboardButton(text='–ù–∞–∑–∞–¥', callback_data=f'sub start {group}')])
        # –°–æ–∑–¥–∞—ë–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏
        kb = InlineKeyboardMarkup(inline_keyboard=buttons)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb)

@router.message(SubscriptionStates.waiting_for_pair)
async def process_pair_input(message: Message, state: FSMContext, bot: Bot):
    pair = message.text.strip().upper()
    data = await state.get_data()
    try:
        await bot.delete_message(message_id=data['last_msg'], chat_id=message.from_user.id)
    except Exception:
        pass
    if pair not in get_usdt_pairs():
        await message.answer("–¢–∞–∫–æ–π –ø–∞—Ä—ã –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    await state.update_data(pair=pair)
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º:", 
        reply_markup=timeframe_inline()
    )
    await state.set_state(SubscriptionStates.waiting_for_timeframe)

@router.callback_query(SubscriptionStates.waiting_for_timeframe)
async def process_timeframe_selection(callback: CallbackQuery, state: FSMContext, bot: Bot):
    timeframe = callback.data.split('_')[1]  # –ù–∞–ø—Ä–∏–º–µ—Ä: "tf_1D"
    data = await state.get_data()
    await state.clear()
    if data['group'] == 'True':
        user_id = config.trading_group_id
    else:
        user_id = callback.from_user.id
    pair = data.get("pair")

    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    await add_subscription(user_id, pair, timeframe)
    signal = get_signal(pair, timeframe)
    await callback.message.delete()
    await callback.message.answer(f"–í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ –ø–∞—Ä–µ {pair} –¢–§ ({interval_conv(timeframe)}).")

    subscriptions = await get_user_subscriptions(user_id)
    if not subscriptions:
        await callback.message.edit_text("–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω—É –ø–∞—Ä—É.", reply_markup=subscription_management_inline(data['group']))
        return

    msg = "–í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —Å–ª–µ–¥—É—é—â–∏–º –ø–∞—Ä–∞–º:\n\n"
    for sub in subscriptions:
        symbol = sub.get("symbol")  # –î–æ—Å—Ç–∞–µ–º –ø–æ –∫–ª—é—á—É
        interval = sub.get("interval")

        msg += f"üîπ {symbol} (–¢–§ - {interval_conv(interval)})\n"
    
    await callback.message.answer(
        text=msg,
        reply_markup=subscription_management_inline(data['group'])
    )
    await asyncio.sleep(10)
    if signal['symbol'] == 'DOGEUSDT':
        symbol = 'DOGEUSDT üêï'
    else:
        symbol = signal['symbol']

    if signal['status'] == 'buy':
        message = f"–ù–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª:\n–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {symbol}\n–ò–Ω—Ç–µ—Ä–≤–∞–ª: {interval_conv(signal['interval'])}\n–°–∏–≥–Ω–∞–ª: Long üî∞"
    else:
        message = f"–ù–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª:\n–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {symbol}\n–ò–Ω—Ç–µ—Ä–≤–∞–ª: {interval_conv(signal['interval'])}\n–°–∏–≥–Ω–∞–ª: Short üîª"

    await bot.send_message(chat_id=user_id, text=message)




@router.callback_query(F.data.startswith('like'))
async def like_symbol(callback: CallbackQuery, state: FSMContext):
    action = callback.data.split()[1]
    user = await get_user(callback.from_user.id)
    if action == 'start':
        msg = '–†–∞–∑–¥–µ–ª –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –ø–∞—Ä—ã\n\n'
        if user['crypto_pairs']:
            pairs = user['crypto_pairs'].split(',')
            msg += f"–í–∞—à —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä:\n\n"
            for pair in pairs:
                msg += f"üîπ {pair}\n"
        else:
            msg += '–°–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä –ø–æ–∫–∞ –ø—É—Å—Ç'
        await callback.message.edit_text(
            text=msg,
            reply_markup=like_inline()
        )
    elif action == 'add':
        msg = '–í–≤–µ–¥–∏—Ç–µ –æ–¥–Ω—É –ø–∞—Ä—É –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é\n\n–ü—Ä–∏–º–µ—Ä: BTCUSDT,EGLDUSDT,XDCUSDT'
        await state.set_state(CryptoPairs.pairs)
        msg = await callback.message.edit_text(
            text=msg,
            reply_markup=close_state()
        )
        await state.update_data(action=action, last_msg=msg.message_id, call='like')

    elif action == 'del':
        await callback.message.edit_text(
            text='–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è',
            reply_markup=like_del_inline(user)
        )
    elif action == 'delete':
        pair_to_delete = callback.data.split()[2]
        user = await get_user(callback.from_user.id)
        
        # –£–¥–∞–ª—è–µ–º –ø–∞—Ä—É –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        await delete_crypto_pair_from_db(callback.from_user.id, pair_to_delete)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –ø–∞—Ä–∞ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞
        await callback.answer(f"–ü–∞—Ä–∞ {pair_to_delete} –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –≤–∞—à–µ–≥–æ —Å–ø–∏—Å–∫–∞ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö.")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        user = await get_user(callback.from_user.id)  # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è
        await callback.message.edit_text(
            text='–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è',
            reply_markup=like_del_inline(user)
        )



@router.message(CryptoPairs.pairs)
async def add_del_pairs(message: Message, state: FSMContext, bot: Bot):
    data = await state.get_data()
    try:
        await bot.delete_message(message_id=data['last_msg'], chat_id=message.from_user.id)
    except Exception:
        pass
    valid_pairs = get_usdt_pairs()

    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–∞—Ä –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    user_input = message.text
    pairs = [pair.strip().upper() for pair in user_input.split(',')]  # –†–∞–∑–¥–µ–ª—è–µ–º, –æ—á–∏—â–∞–µ–º –∏ –ø—Ä–∏–≤–æ–¥–∏–º –∫ –≤–µ—Ä—Ö–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä—ã
    invalid_pairs = [pair for pair in pairs if pair not in valid_pairs]
    if invalid_pairs:
        await message.answer(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä—ã: {', '.join(invalid_pairs)}.\n\n–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä—ã.")
        return

    if not pairs or any(not pair for pair in pairs):
        await message.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –Ω–∞–ø—Ä–∏–º–µ—Ä: BTCUSDT,ETHUSDT")
        return
    
    if data['action'] == 'add':
        if data['call'] == 'like':
            for pair in pairs:
                await add_crypto_pair_to_db(message.from_user.id, pair)  # –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–∞—Ä—ã –≤ –±–∞–∑—É
        else:
            for pair in pairs:
                await add_monitor_pair_to_db(message.from_user.id, pair)  # –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–∞—Ä—ã –≤ –±–∞–∑—É

        await message.answer(f"–î–æ–±–∞–≤–ª–µ–Ω—ã –ø–∞—Ä—ã: {', '.join(pairs)}")
    else:
        if data['call'] == 'like':
            for pair in pairs:
                await delete_crypto_pair_from_db(message.from_user.id, pair)  # –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø–∞—Ä—ã –∏–∑ –±–∞–∑—ã
        else:
            for pair in pairs:
                await delete_monitor_pair_from_db(message.from_user.id, pair)  # –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø–∞—Ä—ã –∏–∑ –±–∞–∑—ã
       
        await message.answer(f"–£–¥–∞–ª–µ–Ω—ã –ø–∞—Ä—ã: {', '.join(pairs)}")

    user = await get_user(message.from_user.id)
    if data['call'] == 'like':
        msg = '–†–∞–∑–¥–µ–ª –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –ø–∞—Ä—ã\n\n'
        if user['crypto_pairs']:
            pairs = user['crypto_pairs'].split(',')
            msg += f"–í–∞—à —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä:\n\n"
            for pair in pairs:
                msg += f"üîπ {pair}\n"
        else:
            msg += '–°–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä –ø–æ–∫–∞ –ø—É—Å—Ç'
        reply_markup=like_inline()
        await message.answer(
        text=msg,
        reply_markup=reply_markup
    )

    else:
        await format_monitor_signals(message, user, True)

    await state.clear()

@router.callback_query(F.data == 'stat data')
async def stat_period_start(callback: CallbackQuery, state: FSMContext):
    kb = [
        [InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]
    ]
    msg = await callback.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î-–ú–ú-–ì–ì–ì–ì:", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
    await state.set_state(StatPeriodStates.waiting_for_start_date)
    await state.update_data(last_msg=msg.message_id)


@router.message(StatPeriodStates.waiting_for_start_date)
async def process_start_date(message: Message, state: FSMContext, bot: Bot):
    start_date = message.text
    data = await state.get_data()
    try:
        await bot.delete_message(chat_id=message.from_user.id, message_id=data['last_msg'])
    except Exception:
        pass
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞—Ç—ã
        new = datetime.datetime.strptime(start_date, '%d-%m-%Y')
    except ValueError:
        kb = [
        [InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]
    ]

        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î-–ú–ú-–ì–ì–ì–ì.", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        return

    await state.update_data(start_date=start_date)
    kb = [
        [InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]
    ]

    msg = await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î-–ú–ú-–ì–ì–ì–ì:", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
    await state.set_state(StatPeriodStates.waiting_for_end_date)
    await state.update_data(last_msg=msg.message_id)


def plural_form(number, forms):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Ñ–æ—Ä–º—É —Å–ª–æ–≤–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —á–∏—Å–ª–∞.
    :param number: –ß–∏—Å–ª–æ
    :param forms: –°–ø–∏—Å–æ–∫ –∏–∑ —Ç—Ä—ë—Ö —Ñ–æ—Ä–º —Å–ª–æ–≤–∞: ['1 —Å–¥–µ–ª–∫–∞', '2 —Å–¥–µ–ª–∫–∏', '5 —Å–¥–µ–ª–æ–∫']
    :return: –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ñ–æ—Ä–º–æ–π —Å–ª–æ–≤–∞
    """
    number = abs(number) % 100
    if 11 <= number <= 19:
        return forms[2]
    number = number % 10
    if number == 1:
        return forms[0]
    if 2 <= number <= 4:
        return forms[1]
    return forms[2]

@router.message(StatPeriodStates.waiting_for_end_date)
async def process_end_date(message: Message, state: FSMContext, bot: Bot):
    end_date = message.text.strip()  # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    data = await state.get_data()
    user_id = message.from_user.id
    try:
        await bot.delete_message(chat_id=user_id, message_id=data['last_msg'])
    except Exception:
        pass

    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã
        parsed_date = datetime.datetime.strptime(end_date, '%d-%m-%Y')
    except ValueError:
        kb = [[InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]]
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î-–ú–ú-–ì–ì–ì–ì.", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        return

    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –¥–∞—Ç—É –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    start_date = data.get("start_date")
    if not start_date:
        kb = [[InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]]
        await message.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        return

    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –¥–∞—Ç—É
        parsed_start_date = datetime.datetime.strptime(start_date, '%d-%m-%Y')
        if parsed_start_date > parsed_date:
            await message.answer("–ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–∑–∂–µ –∫–æ–Ω–µ—á–Ω–æ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.")
            return
    except ValueError:
        kb = [[InlineKeyboardButton(text='–û—Ç–º–µ–Ω–∞', callback_data='stat start')]]
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π –¥–∞—Ç—ã. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î-–ú–ú-–ì–ì–ì–ì.", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
    await state.update_data(end_date=end_date)

    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—é
    start_date_str = parsed_start_date.strftime('%Y-%m-%d')  # –§–æ—Ä–º–∞—Ç YYYY-MM-DD
    end_date_str = parsed_date.strftime('%Y-%m-%d')          # –§–æ—Ä–º–∞—Ç YYYY-MM-DD

    # –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    total_trades, profitable_trades, loss_trades, total_profit = await get_statistics_for_period(
        user_id, start_date_str, end_date_str
    )

    msg = (
            "üìä–°–¥–µ–ª–∫–∏, —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –±–æ—Ç–æ–º –∑–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å:\n\n"
            f"‚ôªÔ∏è –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫: {total_trades}\n\n"
            f"üìó–í –ø—Ä–∏–±—ã–ª—å: {profitable_trades} {plural_form(profitable_trades, ['—Å–¥–µ–ª–∫–∞', '—Å–¥–µ–ª–∫–∏', '—Å–¥–µ–ª–æ–∫'])} (–ü–æ–¥—Ä–æ–±–Ω–µ–µ)\n"
            f"üìï–í —É–±—ã—Ç–æ–∫: {loss_trades} {plural_form(loss_trades, ['—Å–¥–µ–ª–∫–∞', '—Å–¥–µ–ª–∫–∏', '—Å–¥–µ–ª–æ–∫'])} (–ü–æ–¥—Ä–æ–±–Ω–µ–µ)\n\n"
            f"–ß–∏—Å—Ç—ã–π –ø—Ä–æ—Ñ–∏—Ç: {total_profit:.2f}$ üí∞üîã"
        )
    await message.answer(msg)
    await state.clear()

@router.callback_query(F.data.startswith('stat'))
async def statistics(callback: CallbackQuery, state: FSMContext):
    try:
        await state.clear()
    except Exception:
        pass
    action = callback.data.split()[1]
    if action == 'start':
        total_trades, profitable_trades, loss_trades, total_profit = await get_daily_statistics(callback.from_user.id)

        msg = (
            "üìä–°–¥–µ–ª–∫–∏, —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –±–æ—Ç–æ–º –∑–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å:\n\n"
            f"‚ôªÔ∏è –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫: {total_trades}\n\n"
            f"üìó–í –ø—Ä–∏–±—ã–ª—å: {profitable_trades} {plural_form(profitable_trades, ['—Å–¥–µ–ª–∫–∞', '—Å–¥–µ–ª–∫–∏', '—Å–¥–µ–ª–æ–∫'])} (–ü–æ–¥—Ä–æ–±–Ω–µ–µ)\n"
            f"üìï–í —É–±—ã—Ç–æ–∫: {loss_trades} {plural_form(loss_trades, ['—Å–¥–µ–ª–∫–∞', '—Å–¥–µ–ª–∫–∏', '—Å–¥–µ–ª–æ–∫'])} (–ü–æ–¥—Ä–æ–±–Ω–µ–µ)\n\n"
            f"–ß–∏—Å—Ç—ã–π –ø—Ä–æ—Ñ–∏—Ç: {total_profit:.2f}$ üí∞üîã"
        )
        profit = len(await get_stat_db(callback.from_user.id, 'profit'))
        lois = len(await get_stat_db(callback.from_user.id, 'loise'))
        await callback.message.edit_text(
            text=msg,
            reply_markup=stat_inline(profit, lois)
        )
    else:
        forms = await get_stat_db(callback.from_user.id, action)
        # await callback.answer(action)
        n = int(callback.data.split()[2])
        if n < 0:
            await callback.answer('–≠—Ç–æ –Ω–∞—á–∞–ª–æ')
            return
        form = forms[n]
        msg = f"–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {form['symbol']} | {interval_conv(form['interval'])}\n\n"
        msg += f"–¶–µ–Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è: {round(form['coin_buy_price'], 2)}$ üìà\n"
        msg += f"–¶–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è: {round(form['coin_sale_price'], 2)}$ üìà\n"
        if form['buy_price'] < form['sale_price']:
            profit = form['sale_prget_stat_dbice'] - form['buy_price']
            msg += f"–ü—Ä–∏–±—ã–ª—å: {round(profit, 2)}$üí∏üîã\n\n"
        else:
            profit = form['buy_price'] - form['sale_price']
            msg += f"–£–±—ã—Ç–æ–∫: {round(profit, 2)}$ü§ïü™´\n\n"
        msg += f"–û–±—ä–µ–º —Å–¥–µ–ª–∫–∏: {round(form['buy_price'], 2)}$ üíµ\n\n"
        msg += f"–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –∑–∞–∫—Ä—ã—Ç–∏—è:\n‚è±Ô∏è{form['sale_time']}\n\n"
        msg += f"–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞:\n‚è±Ô∏è{form['buy_time']}\n"
        await callback.message.edit_text(
            text=msg,
            reply_markup=stat_inline_n(n, action, len(forms), "stat")
        )
        

@router.message(Command("start"))
async def start_message(message: Message, bot: Bot):
    if not await get_user(message.from_user.id):
        await set_user(message.from_user.id, 5.0, 50000.0)
    user = await get_user(message.from_user.id)
    await message.answer(
        f"–ë–æ—Ç –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∏–ª—å—Ç—Ä–∞ CM_Laguerre PPO PercentileRank Mkt Tops & Bottoms\n–í–∞—à –±–∞–ª–∞–Ω—Å: {round(user['balance'])}$  üí∏",
        reply_markup=start_inline()
    )

@router.callback_query(F.data.startswith('orders'))
async def orders(callback: CallbackQuery, bot: Bot):
    action = callback.data.split()[1]
    if action == 'start':
        open = len(await get_all_orders(callback.from_user.id, 'open'))
        close = len(await get_all_orders(callback.from_user.id, 'close'))
        await callback.message.edit_text(
            text='–í–∞—à–∏ —Å–¥–µ–ª–∫–∏', 
            reply_markup=orders_inline(open, close)
        )
    else:
        forms = await get_all_orders(callback.from_user.id, action)
        n = int(callback.data.split()[2])
        if n < 0:
            await callback.answer('–≠—Ç–æ –Ω–∞—á–∞–ª–æ')
            return

        form = forms[n]
        msg = f"–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {form['symbol']} | {interval_conv(form['interval'])}\n\n"
        msg += f"–¶–µ–Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è: {round(form['coin_buy_price'], 2)}$ üìà\n"

        # msg += f"–¢–§: {form['interval']}\n"
        if action == 'open':
            msg += f"–û–±—ä–µ–º —Å–¥–µ–ª–∫–∏: {round(form['buy_price'], 2)}$ üíµ\n\n"
            msg += f"–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è:\n‚è±Ô∏è{form['buy_time']}\n"
        else:
            msg += f"–¶–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è: {form['coin_sale_price']}$ üìà\n"

            if form['buy_price'] < form['sale_price']:
                profit = form['sale_price'] - form['buy_price']
                msg += f"–ü—Ä–∏–±—ã–ª—å: {round(profit, 2)}$üí∏üîã\n\n"
            else:
                profit = form['buy_price'] - form['sale_price']
                msg += f"–£–±—ã—Ç–æ–∫: {round(profit, 2)}$ü§ïü™´\n\n"

            msg += f"–û–±—ä–µ–º —Å–¥–µ–ª–∫–∏: {round(form['buy_price'], 2)}$ üíµ\n\n"
            msg += f"–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –∑–∞–∫—Ä—ã—Ç–∏—è:\n‚è±Ô∏è{form['sale_time']}\n\n"
            msg += f"–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞:\n‚è±Ô∏è{form['buy_time']}\n"
        await callback.message.edit_text(
            text=msg,
            reply_markup=orders_inline_n(n, action, len(forms), "orders")
        )


async def split_message_and_edit(bot_message, text, reply_markup=None):
    while len(text) > 4096:
        chunk = text[:4096].rsplit('\n', 1)[0]  # –†–∞–∑–±–∏—Ç—å –ø–æ —Å—Ç—Ä–æ–∫–∞–º
        await bot_message.edit_text(text=chunk)
        text = text[len(chunk):]
    await bot_message.edit_text(text=text, reply_markup=reply_markup)

    
@router.callback_query(F.data.startswith('signals'))
async def signals(callback: CallbackQuery, bot: Bot):
    action = callback.data.split()[1]
    if action == 'start':
        sale = await count_signals('sale')
        buy = await count_signals('buy')
        # forms = all_signals_no_signal()
        # old_symbol = 'start'
        # msg_parts = []
        # for form in forms:
        #     if old_symbol != form['symbol']:
        #         if old_symbol == 'start':
        #             msg_parts.append(f"{form['symbol']} - {buy_sale(form['status'], interval_conv(form['interval']))}")
        #         else:
        #             msg_parts.append(f"\n{form['symbol']} - {buy_sale(form['status'], interval_conv(form['interval']))}")
        #         old_symbol = form['symbol']
        #     else:
        #         msg_parts.append(buy_sale(form['status'], interval_conv(form['interval'])))
        #         old_symbol = form['symbol']

        # msg = "".join(msg_parts)
        # await split_message_and_edit(callback.message, msg, signals_inline(buy, sale))
        await callback.message.edit_text(
            text='–°–∏–≥–Ω–∞–ª—ã', 
            reply_markup=signals_inline(buy, sale)
        )
    else:
        interval = action.split('_')[1]
        action = action.split('_')[0]
        if interval == 's':
            n = int(callback.data.split()[0].split('_')[1])
            if n < 0:
                await callback.answer('–≠—Ç–æ –Ω–∞—á–∞–ª–æ')
                return

            if action == 'buy':
                forms = await all_signals_no_signal()
            else:
                forms = await get_all_intervals_for_pairs_with_status(action)
            grouped_signals = {}

            # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ —Å–∏–º–≤–æ–ª—É
            INTERVAL_ORDER = {'1d': 1, '4h': 2, '1h': 3, '30m': 4}  # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã

            # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ —Å–∏–º–≤–æ–ª—É
            for form in forms:
                symbol = form['symbol']
                interval = form['interval']
                status = buy_sale(form['status'], interval_conv(interval))
                if symbol not in grouped_signals:
                    grouped_signals[symbol] = []
                grouped_signals[symbol].append({'interval': interval, 'status': status})

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É (1d ‚Üí 4h ‚Üí 1h ‚Üí 30m)
            for symbol in grouped_signals:
                grouped_signals[symbol].sort(key=lambda x: INTERVAL_ORDER[x['interval']])

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏
            msg_parts = []
            for symbol, signals in grouped_signals.items():
                msg_parts.append(f"{symbol} - {''.join(signal['status'] for signal in signals)}")

            msg = "\n".join(msg_parts)
            chunks = split_text_to_chunks(msg)
            await callback.message.edit_text(
                text=chunks[n],
                reply_markup=interval_inline(action, n,len(chunks))
            )
            # await split_message_and_edit(callback.message, msg, interval_inline(action, 0))

            # await callback.message.edit_text(
            #     text=msg,
            #     reply_markup=interval_inline(action)
            # )
        else:
            n_back = int(callback.data.split()[0].split('_')[1])

            n = int(callback.data.split()[2])
            if n < 0:
                await callback.answer('–≠—Ç–æ –Ω–∞—á–∞–ª–æ')
                return

            forms = await all_signals(action, interval)
            # form = forms[n]
            if action == 'sale':
                signal = '–ø—Ä–æ–¥–∞–∂—É'
            else:
                signal = '–ø–æ–∫—É–ø–∫—É'
            msg = f"–°–∏–≥–Ω–∞–ª –Ω–∞ {signal}\n"
            # msg += f"–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {form['symbol']}\n"
            msg += f"–¢–§: {interval_conv(interval)}\n"
            for form in forms:
                msg += f"{form['symbol']} - {buy_sale(action, interval)}\n"
            # msg += f"–¶–µ–Ω–∞ –∑–∞ –ø–æ–∫—É–ø–∫—É: {form['buy_price']}\n"
            # msg += f"–¶–µ–Ω–∞ –∑–∞ –ø—Ä–æ–¥–∞–∂—É {form['sale_price']}"
            chunks = split_text_to_chunks(msg)
            await callback.message.edit_text(
                text=chunks[n],
                reply_markup=signals_inline_n(action, len(chunks), n_back, interval, n )
            )
            # await split_message_and_edit(callback.message, msg, signals_inline_n(action))
    
            # await callback.message.edit_text(
            #     text=msg,
            #     reply_markup=signals_inline_n(action)
            # )

@router.callback_query(F.data.startswith("table"))
async def table(callback: CallbackQuery, bot: Bot):
    action = callback.data.split()[1]
    if action == 'signals':
        columns, data = await fetch_signals()

        file_name = create_xls(columns, data)

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ Telegram
        xls_file = FSInputFile(file_name)  # –°–æ–∑–¥–∞–µ–º FSInputFile —Å –ø—É—Ç–µ–º –∫ —Ñ–∞–π–ª—É

        with open(file_name, 'rb') as file:
            await bot.send_document(chat_id=callback.from_user.id, document=xls_file, caption="–í–æ—Ç –≤–∞—à —Ñ–∞–π–ª üìÑ")

    elif action == 'stat':
        columns, data = await fetch_stat(callback.from_user.id)

        if not data:
            await callback.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
            return

        # –°–æ–∑–¥–∞–µ–º Excel —Ñ–∞–π–ª
        file_name = create_xls(columns, data, file_name="orders_stat.xlsx")

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ Telegram
        xls_file = FSInputFile(file_name)

        with open(file_name, 'rb') as file:
            await bot.send_document(chat_id=callback.from_user.id, document=xls_file, caption="–í–æ—Ç –≤–∞—à —Ñ–∞–π–ª —Å –∑–∞–∫–∞–∑–∞–º–∏ üìÑ")


@router.callback_query(F.data.startswith('monitor'))
async def monitoring(callback: CallbackQuery, state: FSMContext):
    action = callback.data.split()[1]
    user = await get_user(callback.from_user.id)
    if action == 'start':
        await format_monitor_signals(callback, user)
    elif action == 'del':
        await callback.message.edit_text(
            text='–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è',
            reply_markup=monitor_del_inline(user)
        )
    elif action == 'delete':
        pair_to_delete = callback.data.split()[2]
        user = await get_user(callback.from_user.id)
        
        # –£–¥–∞–ª—è–µ–º –ø–∞—Ä—É –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        await delete_monitor_pair_from_db(callback.from_user.id, pair_to_delete)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –ø–∞—Ä–∞ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞
        await callback.answer(f"–ü–∞—Ä–∞ {pair_to_delete} –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –≤–∞—à–µ–≥–æ —Å–ø–∏—Å–∫–∞")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        user = await get_user(callback.from_user.id)  # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è
        await callback.message.edit_text(
            text='–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è',
            reply_markup=monitor_del_inline(user)
        )

    else:
        msg = '–í–≤–µ–¥–∏—Ç–µ –æ–¥–Ω—É –ø–∞—Ä—É –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é\n\n–ü—Ä–∏–º–µ—Ä: BTCUSDT,EGLDUSDT,XDCUSDT'
        await state.set_state(CryptoPairs.pairs)
        msg = await callback.message.edit_text(
            text=msg,
            reply_markup=close_state()
        )
        await state.update_data(action=action, last_msg=msg.message_id, call='monitor')


@router.callback_query(F.data.startswith('settings'))
async def settings(callback: CallbackQuery, state: FSMContext, bot: Bot):
    action = callback.data.split()[1]
    if action == 'start':
        user = await get_user(callback.from_user.id)
        text = '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–∏—è –±–æ—Ç–æ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞ –¥–ª—è —Å–æ–≤–µ—Ä—à–µ–Ω–∏—è —Å–¥–µ–ª–æ–∫.\n\n'
        text += '–ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å % –æ—Ç –æ–±—â–µ–≥–æ –¥–µ–ø–æ–∑–∏—Ç–∞ –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –±—É–¥—É—Ç —Å–æ–≤–µ—Ä—à–∞—Ç—å—Å—è —Å–¥–µ–ª–∫–∏ –±–æ—Ç–æ–º, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π "–ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç"\n\n'
        text += f"–¢–µ–∫—É—â–∏–π –ø—Ä–æ—Ü–µ–Ω—Ç: {user['percent']}%"
        await callback.message.edit_text(
            text=text,
            reply_markup=settings_inline()
        )
    elif action == 'percent':
        msg = await callback.message.edit_text(
            '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç',
            reply_markup=close_state()
        )
        await state.set_state(EditPercent.new)
        await state.update_data(last_msg=msg.message_id)
    

@router.message(EditPercent.new)
async def edit_percent(message: Message, state: FSMContext, bot: Bot):
    data = await state.get_data()
    await bot.delete_message(chat_id=message.from_user.id, message_id=data['last_msg'])
    try:
        percent = float(message.text)
        await up_percent(message.from_user.id, percent)
        await message.answer('–ü—Ä–æ—Ü–µ–Ω—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!')
        await state.clear()
    except ValueError:
        await message.answer(
            '–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!', 
            reply_markup=close_state()
        )
        return
    

@router.callback_query(F.data == 'close_state')
async def close_state_cal(callback: CallbackQuery, state: FSMContext):
    try:
        await state.clear()
    except Exception:
        pass
    await callback.message.edit_text(
        '–ë–æ—Ç –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∏–ª—å—Ç—Ä–∞ CM_Laguerre PPO PercentileRank Mkt Tops & Bottoms',
        reply_markup=start_inline()
    )

        


@router.callback_query(F.data == 'start')
async def start_cal(callback: CallbackQuery, state: FSMContext):
    user = await get_user(callback.from_user.id)

    await callback.message.edit_text(
        text=f"–ë–æ—Ç –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∏–ª—å—Ç—Ä–∞ CM_Laguerre PPO PercentileRank Mkt Tops & Bottoms\n–í–∞—à –±–∞–ª–∞–Ω—Å: {round(user['balance'])}$  üí∏",
        reply_markup=start_inline()
    )
