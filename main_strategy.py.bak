import logging

import ccxt.async_support as ccxt
import pandas as pd
from aiogram.enums import ParseMode
from scipy.stats import percentileofscore
import asyncio
from aiogram.client.session.aiohttp import AiohttpSession
from aiogram.client.bot import DefaultBotProperties
from aiogram import Bot
from strategy_logic.get_all_coins import get_usdt_pairs
from config import config
# from db import *
import datetime as dt
from strategy_logic.rsi import *
from strategy_logic.vsa import *
from strategy_logic.price_action import get_pattern_price_action
from deepseek.deepsekk import analyze_trading_signals
from config import config
from strategy_logic.stop_loss import *
from strategy_logic.moon_bot_strategy import StrategyMoonBot, load_strategy_params, Context
# Initialize moon bot with default params initially - will be replaced with user-specific in the processing loop
moon = StrategyMoonBot(load_strategy_params())
from db.orders import *
from db.orders import get_open_orders, get_order_by_id, close_order, save_order, get_active_positions
from db.orders import get_active_btc_position_size, get_daily_profit, init_db
import pytz
from dateutil.parser import parse
from db.orders import get_user_open_orders, get_user_balance
from strategy_logic.user_strategy_params import load_user_params
from strategy_logic.pump_dump import pump_dump_main
from strategy_logic.cm_settings import load_cm_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ CM
from strategy_logic.divergence_settings import load_divergence_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏
from strategy_logic.rsi_settings import load_rsi_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ RSI
from strategy_logic.pump_dump_settings import load_pump_dump_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ Pump/Dump
from strategy_logic.pump_dump_trading import process_pump_dump_signal  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ Pump/Dump
from strategy_logic.trading_type_settings import load_trading_type_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ç–∏–ø–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏
from strategy_logic.trading_settings import load_trading_settings  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ç–æ—Ä–≥–æ–≤–ª–∏
from pathlib import Path
import json
from typing import Callable, Awaitable, Dict, Tuple, Any
import requests
import time


bot = Bot(token=config.tg_bot_token, default=DefaultBotProperties(parse_mode="HTML"))

async def close_order_with_notification(user_id, order_id, current_price, close_reason):
    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ä–¥–µ—Ä–µ
    order = await get_order_by_id(order_id)
    
    if order:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–∫—Ä—ã—Ç –ª–∏ —É–∂–µ –æ—Ä–¥–µ—Ä
            if order.get('status', 'OPEN') == 'CLOSED':
                print(f"–û—Ä–¥–µ—Ä {order_id} —É–∂–µ –∑–∞–∫—Ä—ã—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–∫—Ä—ã—Ç–∏–µ")
                return False
                
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
            current_balance = await get_user_balance(user_id)
            print(f"–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã—Ç–∏–µ–º –æ—Ä–¥–µ—Ä–∞: {current_balance}")
                
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—Ä–¥–µ—Ä –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
            result = await close_order(order_id, current_price)
            
            # –ï—Å–ª–∏ –∑–∞–∫—Ä—ã—Ç–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å (–æ—Ä–¥–µ—Ä —É–∂–µ –∑–∞–∫—Ä—ã—Ç), –≤—ã—Ö–æ–¥–∏–º
            if not result:
                print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–∫—Ä—ã—Ç—å –æ—Ä–¥–µ—Ä {order_id}, –≤–æ–∑–º–æ–∂–Ω–æ –æ–Ω —É–∂–µ –∑–∞–∫—Ä—ã—Ç")
                return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–æ–ª—è entry_price –∏–ª–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª–µ–π
            entry_price = None
            if 'entry_price' in order:
                entry_price = order['entry_price']
            elif 'price' in order:
                entry_price = order['price']
            elif 'open_price' in order:
                entry_price = order['open_price']
            elif 'coin_buy_price' in order:
                entry_price = order['coin_buy_price']
            
            if entry_price is None:
                # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ü–µ–Ω—É –≤—Ö–æ–¥–∞, –≤—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ä–¥–µ—Ä–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                print(f"–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ —Å —Ü–µ–Ω–æ–π –≤—Ö–æ–¥–∞. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ä–¥–µ—Ä–∞: {order}")
                await bot.send_message(user_id, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ—Ä–¥–µ—Ä–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞")
                return False
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            position_side = order.get('position_side', order.get('side', 'LONG'))  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é LONG, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–∏–±—ã–ª—å/—É–±—ã—Ç–æ–∫
            pnl_percent = ((current_price - entry_price) / entry_price) * 100
            if position_side == 'SHORT':
                pnl_percent = -pnl_percent
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
            qty = order.get('qty', order.get('amount', 0))
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø —Ç–æ—Ä–≥–æ–≤–ª–∏ –∏ –ø–ª–µ—á–æ
            trading_type = order.get('trading_type', 'spot')
            leverage = order.get('leverage', 1)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–ª–µ—á–æ –¥–ª—è futures
            if trading_type == 'futures':
                pnl_percent = pnl_percent * leverage
            
            pnl = (current_price - entry_price) * qty
            if position_side == 'SHORT':
                pnl = -pnl
            
            # –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–ª–µ—á–æ, —É–º–Ω–æ–∂–∞–µ–º PnL –Ω–∞ –ø–ª–µ—á–æ
            if trading_type == 'futures':
                pnl = pnl * leverage
                
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ –ú–°–ö
            moscow_tz = pytz.timezone('Europe/Moscow')
            now = dt.datetime.now(moscow_tz)
            current_date = now.strftime('%d.%m.%Y')
            current_time = now.strftime('%H:%M')
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è –æ—Ä–¥–µ—Ä–∞ –∏–∑ UTC –≤ –ú–°–ö
            open_time = None
            if 'open_time' in order:
                open_time = order['open_time']
            elif 'buy_time' in order:
                open_time = int(dt.datetime.timestamp(order['buy_time']))
            else:
                open_time = int(dt.datetime.now().timestamp())
                
            buy_time_utc = dt.datetime.fromtimestamp(open_time)
            buy_time_moscow = pytz.utc.localize(buy_time_utc).astimezone(moscow_tz)
            buy_date = buy_time_moscow.strftime('%d.%m.%Y')
            buy_time = buy_time_moscow.strftime('%H:%M')
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º–∞—Ä–Ω—ã–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å
            daily_profit = await get_daily_profit(user_id, now.date())
            
            # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å –ø–æ—Å–ª–µ –≤–æ–∑–≤—Ä–∞—Ç–∞ —Å—Ä–µ–¥—Å—Ç–≤
            new_balance = await get_user_balance(user_id)
            
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞
            balance_change = new_balance - current_balance
            print(f"–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –æ—Ä–¥–µ—Ä–∞: {new_balance} (–∏–∑–º–µ–Ω–µ–Ω–∏–µ: {balance_change})")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∏–º–≤–æ–ª
            direction = "Long üî∞" if position_side == 'LONG' else "Short üîª"
            symbol = order.get('symbol', 'UNKNOWN')
            symbol_base = symbol.replace('USDT', '')
            timeframe = order.get('timeframe', order.get('interval', '1h'))
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∏—á–∏–Ω—ã –∑–∞–∫—Ä—ã—Ç–∏—è
            if close_reason == "TP":
                message = (
                    f"üî¥ <b>–ó–ê–ö–†–´–¢–ò–ï –û–†–î–ï–†–ê</b> {symbol} {timeframe}\n\n"
                    f"–ë–∏—Ä–∂–∞: {order.get('exchange', 'Bybit')}\n"
                    f"–¢–∏–ø —Ç–æ—Ä–≥–æ–≤–ª–∏: {order.get('trading_type', 'spot').upper()}"
                    f"{' | –ü–ª–µ—á–æ: x' + str(order.get('leverage', 1)) if order.get('trading_type') == 'futures' else ''}\n\n"
                    f"üéØ‚úÖ –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¢–µ–π–∫-–ü—Ä–æ—Ñ–∏—Ç\n"
                    f"üí∏üîã–ü—Ä–∏–±—ã–ª—å –ø–æ —Å–¥–µ–ª–∫–µ: {pnl_percent:.2f}% ({pnl:.2f} USDT)\n\n"
                    f"‚ôªÔ∏è–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞: {entry_price:.2f}$\n"
                    f"üìà–¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏: {current_price:.4f}$\n"
                    f"üõë–ü—Ä–æ–¥–∞–Ω–æ: {qty:.6f} {symbol_base} ({(qty * current_price):.2f} USDT)\n\n"
                    f"üìÜ–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞: {buy_date}\n"
                    f"üïê–í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è: {buy_time} –ú—Å–∫\n"
                    f"üìâ–¢–§ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏: {timeframe}\n"
                    f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {direction}\n\n"
                    f"–û–±—â–∏–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å: {'+' if daily_profit > 0 else ''} {daily_profit:.2f} USDT {'üí∏üîã' if daily_profit > 0 else 'ü§ï'}\n"
                    f"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance:.2f} USDT"
                )
            else:  # SL
                message = (
                    f"üî¥ <b>–ó–ê–ö–†–´–¢–ò–ï –û–†–î–ï–†–ê</b> {symbol} {timeframe}\n\n"
                    f"–ë–∏—Ä–∂–∞: {order.get('exchange', 'Bybit')}\n"
                    f"–¢–∏–ø —Ç–æ—Ä–≥–æ–≤–ª–∏: {order.get('trading_type', 'spot').upper()}"
                    f"{' | –ü–ª–µ—á–æ: x' + str(order.get('leverage', 1)) if order.get('trading_type') == 'futures' else ''}\n\n"
                    f"üìõ–ó–∞–∫—Ä—ã—Ç–æ –ø–æ –°—Ç–æ–ø-–ª–æ—Å—Å—É\n"
                    f"ü§ïü™´–£–±—ã—Ç–æ–∫ –ø–æ —Å–¥–µ–ª–∫–µ: {pnl_percent:.2f}% ({pnl:.2f} USDT)\n\n"
                    f"‚ôªÔ∏è–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞: {entry_price:.2f}$\n"
                    f"üìà–¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏: {current_price:.4f}$\n"
                    f"üõë–ü—Ä–æ–¥–∞–Ω–æ: {qty:.6f} {symbol_base} ({(qty * current_price):.2f} USDT)\n\n"
                    f"üìÜ–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞: {buy_date}\n"
                    f"üïê–í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è: {buy_time} –ú—Å–∫\n"
                    f"üìâ–¢–§ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏: {timeframe}\n"
                    f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {direction}\n\n"
                    f"–û–±—â–∏–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å: {'+' if daily_profit > 0 else ''} {daily_profit:.2f} USDT {'üí∏üîã' if daily_profit > 0 else 'ü§ï'}\n"
                    f"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance:.2f} USDT"
                )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await bot.send_message(user_id, message)
            
            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ—Ä–¥–µ—Ä–∞: {e}")
            await bot.send_message(user_id, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ—Ä–¥–µ—Ä–∞: {e}")
            return False
    return False

"""–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ - –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"""
SHORT_GAMMA = 0.4
LONG_GAMMA = 0.8
LOOKBACK_T = 21
LOOKBACK_B = 15
PCTILE = 90

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã RSI –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏
RSI_LENGTH = 7
LB_RIGHT = 3
LB_LEFT = 3
RANGE_UPPER = 60
RANGE_LOWER = 5
TAKE_PROFIT_RSI_LEVEL = 80

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–æ–ø-–ª–æ—Å—Å–∞
STOP_LOSS_TYPE = "PERC"  # "ATR", "PERC", "NONE"
STOP_LOSS_PERC = 5.0  # –ü—Ä–æ—Ü–µ–Ω—Ç –¥–ª—è —Å—Ç–æ–ø-–ª–æ—Å—Å–∞
ATR_LENGTH = 14  # –ü–µ—Ä–∏–æ–¥ ATR
ATR_MULTIPLIER = 3.5  # –ú–Ω–æ–∂–∏—Ç–µ–ª—å ATR

exchange = ccxt.bybit()  # –ü–µ—Ä–µ–¥–∞—ë–º —Å–µ—Å—Å–∏—é –≤ CCXT
# timeframes = ['1d', '4h', '1h', '30m']


symbols = get_usdt_pairs()

async def fetch_ohlcv(symbol, timeframe='1h', limit=500, retries=3, delay=5):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –≤ —Å–ª—É—á–∞–µ —Ç–∞–π–º-–∞—É—Ç–∞."""
    for attempt in range(retries):
        try:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['hl2'] = (df['high'] + df['low']) / 2  # –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ —Å–≤–µ—á–∏
            return df
        except ccxt.RequestTimeout:
            print(f"Timeout fetching {symbol} {timeframe}, retrying {attempt + 1}/{retries}...")
            await asyncio.sleep(delay)  # Wait before retrying
    print(f"Failed to fetch {symbol} {timeframe} after {retries} attempts.")
    return None


def laguerre_filter(series, gamma):
    """Laguerre-—Ñ–∏–ª—å—Ç—Ä."""
    L0, L1, L2, L3, f = np.zeros_like(series), np.zeros_like(series), np.zeros_like(series), np.zeros_like(series), np.zeros_like(series)

    for i in range(1, len(series)):
        L0[i] = (1 - gamma) * series[i] + gamma * L0[i - 1]
        L1[i] = -gamma * L0[i] + L0[i - 1] + gamma * L1[i - 1]
        L2[i] = -gamma * L1[i] + L1[i - 1] + gamma * L2[i - 1]
        L3[i] = -gamma * L2[i] + L2[i - 1] + gamma * L3[i - 1]
        f[i] = (L0[i] + 2 * L1[i] + 2 * L2[i] + L3[i]) / 6

    return f


def calculate_ppo(df, cm_settings):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ Laguerre PPO –∏ –ø—Ä–æ—Ü–µ–Ω—Ç–∏–ª—å–Ω–æ–≥–æ —Ä–∞–Ω–≥–∞ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏."""
    df['lmas'] = laguerre_filter(df['hl2'].values, cm_settings['SHORT_GAMMA'])
    df['lmal'] = laguerre_filter(df['hl2'].values, cm_settings['LONG_GAMMA'])

    df['ppoT'] = (df['lmas'] - df['lmal']) / df['lmal'] * 100
    df['ppoB'] = (df['lmal'] - df['lmas']) / df['lmal'] * 100

    df['pctRankT'] = df['ppoT'].rolling(cm_settings['LOOKBACK_T']).apply(lambda x: percentileofscore(x, x.iloc[-1]), raw=False)
    df['pctRankB'] = df['ppoB'].rolling(cm_settings['LOOKBACK_B']).apply(lambda x: percentileofscore(x, x.iloc[-1]), raw=False) * -1

    return df


def find_cm_signal(df, cm_settings):
    """–ù–∞—Ö–æ–¥–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª, –Ω–∞—á–∏–Ω–∞—è —Å —Ç–µ–∫—É—â–µ–π —Å–≤–µ—á–∏ –∏ —à–∞–≥–∞—è –Ω–∞–∑–∞–¥."""
    for i in range(len(df) - 1, -1, -1):
        if df['pctRankT'].iloc[i] >= cm_settings['PCTILE']:
            return "short", df.iloc[i]
        if df['pctRankB'].iloc[i] <= -cm_settings['PCTILE']:
            return "long", df.iloc[i]
    return "No Signal", None


async def wait_for_next_candle(timeframe):
    """–û–∂–∏–¥–∞–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Å–≤–µ—á–∏ –∏ –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–π."""
    # –í—ã—á–∏—Å–ª—è–µ–º, —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Å—Ç–∞–ª–æ—Å—å –¥–æ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏
    tf_to_seconds = {
        '1d': 86400,
        '4h': 14400,
        '1h': 3600,
        '30m': 1800,
        '15m': 900,
        '5m': 300,
        '3m': 180,
        '1m': 60,
    }
    
    start_time = tf_to_seconds.get(timeframe, 60 * 60)  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 1 —á–∞—Å
    
    # –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö —Å –Ω–∞—á–∞–ª–∞ —ç–ø–æ—Ö–∏
    now = dt.datetime.now()
    current_time = int(now.timestamp())
    
    # –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —Ç–µ–∫—É—â–µ–π —Å–≤–µ—á–∏
    current_candle_start = current_time - (current_time % start_time)
    
    # –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏
    next_candle_start = current_candle_start + start_time
    
    # –°–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –æ—Å—Ç–∞–ª–æ—Å—å –¥–æ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏
    seconds_to_wait = next_candle_start - current_time

    if seconds_to_wait > 0:
        print(f"Waiting for next {timeframe} candle: {seconds_to_wait:.2f} seconds")
        await asyncio.sleep(seconds_to_wait)
    else:
        print(f"Unknown timeframe: {timeframe}, waiting 60 seconds as fallback")
        await asyncio.sleep(60)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω


TIMEFRAMES = ["1m", "3m", "5m", "15m", "30m", "1h"]
symbols    = ["BTCUSDT", "ETHUSDT", "DOGEUSDT", "LTCUSDT", "XRPUSDT", "SOLUSDT", "TRXUSDT"]

async def process_tf(tf: str):
    while True:
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –≤–∫–ª—é—á–µ–Ω–Ω—ã–º bybit
        active_users = []
        settings_path = Path("user_settings")
        if settings_path.exists():
            for json_file in settings_path.glob("*.json"):
                try:
                    with json_file.open("r", encoding="utf-8") as fh:
                        settings = json.load(fh)
                    user_id = int(json_file.stem)
                    if settings.get("bybit", False):
                        active_users.append(user_id)
                        print(f"[INFO] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Bybit")
                except Exception as e:
                    print(f"[ERROR] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {json_file.name}: {e}")
        
        if not active_users:
            print("[INFO] –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –≤–∫–ª—é—á–µ–Ω–Ω—ã–º Bybit –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö")
            await asyncio.sleep(60)  # –ñ–¥–µ–º –º–∏–Ω—É—Ç—É –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            continue
            
        print(f"[INFO] –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ Bybit: {active_users}")
        
        btc_df = await fetch_ohlcv("BTCUSDT", "5m", 300)
        for symbol in symbols:
            df5 = await fetch_ohlcv(symbol, "5m", 300)
            dft = await fetch_ohlcv(symbol, tf,   200)
            if df5 is None or dft is None: continue

            ticker  = await exchange.fetch_ticker(symbol)
            ctx = Context(
                ticker_24h=ticker,
                hourly_volume=df5["volume"].iloc[-12:].sum(),
                btc_df=btc_df,
            )

            for uid in active_users:
                open_order = await get_open_order(uid, "bybit", symbol, tf)

                # Get user-specific strategy parameters
                user_moon = StrategyMoonBot(load_strategy_params(uid))
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ CM –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                cm_settings = load_cm_settings(uid)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                divergence_settings = load_divergence_settings(uid)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ RSI –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                rsi_settings = load_rsi_settings(uid)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Pump/Dump –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                pump_dump_settings = load_pump_dump_settings(uid)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–∏–ø–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                trading_type_settings = load_trading_type_settings(uid)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–æ—Ä–≥–æ–≤–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                trading_settings = load_trading_settings(uid)
                trading_type = trading_settings["trading_type"]
                leverage = trading_settings["leverage"]
                
                # ---------- –≤—Ö–æ–¥ ----------
                if open_order is None:
                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω—ã Price Action —Å —É—á–µ—Ç–æ–º —Ç–∏–ø–∞ —Ä—ã–Ω–∫–∞
                    pattern = await get_pattern_price_action(dft[['timestamp', 'open', 'high', 'low', 'close']].values.tolist()[-5:], trading_type)
                    dft = calculate_ppo(dft, cm_settings)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                    dft = calculate_ema(dft)
                    cm_signal, last_candle = find_cm_signal(dft, cm_settings)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º RSI —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
                    dft = calculate_rsi(dft, period=rsi_settings['RSI_PERIOD'])
                    dft = calculate_ema(dft, 
                                       fast_period=rsi_settings['EMA_FAST'], 
                                       slow_period=rsi_settings['EMA_SLOW'])
                    
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã RSI —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
                    rsi = generate_signals_rsi(dft, 
                                              overbought=rsi_settings['RSI_OVERBOUGHT'], 
                                              oversold=rsi_settings['RSI_OVERSOLD'])
                    rsi_signal = rsi['signal_rsi'].iloc[-1]

                    diver_signals = generate_trading_signals(
                        dft, 
                        rsi_length=divergence_settings['RSI_LENGTH'], 
                        lbR=divergence_settings['LB_RIGHT'], 
                        lbL=divergence_settings['LB_LEFT'], 
                        take_profit_level=divergence_settings['TAKE_PROFIT_RSI_LEVEL'],
                        stop_loss_type=divergence_settings['STOP_LOSS_TYPE'],
                        stop_loss_perc=divergence_settings['STOP_LOSS_PERC'],
                        atr_length=divergence_settings['ATR_LENGTH'],
                        atr_multiplier=divergence_settings['ATR_MULTIPLIER']
                    )
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
                    print(f"[SIGNAL_DEBUG] {exchange.id.upper()} {symbol} {tf} => CM={cm_signal}, RSI={rsi_signal}")
                    
                    import datetime as dt
                    
                    # Determine position side (LONG/SHORT)
                    position_side = "LONG"  # Default to LONG
                    
                    # For futures, consider short signals
                    if trading_type == "futures":
                        # Check signals
                        has_long_signal = cm_signal == "long" or rsi_signal == "Long"
                        has_short_signal = cm_signal == "short" or rsi_signal == "Short"
                        
                        # Check pattern for LONG
                        if pattern is not None and pattern != "" and pattern.startswith("Bull"):
                            has_long_signal = True
                            print(f"[LONG_SIGNAL] Found from Price Action: {pattern}")
                        
                        # Logger
                        print(f"[POSITION_SIGNALS] {exchange.id.upper()} {symbol} {tf} => LONG_signals={has_long_signal}, SHORT_signals={has_short_signal}")
                        
                        # Balance LONG/SHORT
                        current_hour = dt.datetime.now().hour
                        current_minute = dt.datetime.now().minute
                        
                        # Decision logic
                        if has_long_signal and not has_short_signal:
                            position_side = "LONG"
                            print(f"[POSITION] Using LONG signal")
                        elif has_short_signal and not has_long_signal:
                            position_side = "SHORT"
                            print(f"[POSITION] Using SHORT signal")
                        elif has_long_signal and has_short_signal:
                            # Use hour parity for balance
                            if current_hour % 2 == 0:
                                position_side = "LONG"
                                print(f"[POSITION] Both signals present, using LONG for even hour")
                            else:
                                position_side = "SHORT"
                                print(f"[POSITION] Both signals present, using SHORT for odd hour")
                        else:
                            # No clear signals, force alternating based on minute
                            if current_minute % 2 == 0:
                                position_side = "LONG"
                                print(f"[POSITION] No signals, forcing LONG for even minute")
                            else:
                                position_side = "SHORT"
                                print(f"[POSITION] No signals, forcing SHORT for odd minute")
                    
                    # –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ position_side –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ "LONG", –ª–∏–±–æ "SHORT"
                    # –ù–∏–∫–∞–∫–æ–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ position_side –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è
                    
                    # –°–æ–∑–¥–∞–µ–º TP/SL —É—Ä–æ–≤–Ω–∏ —Å —É—á–µ—Ç–æ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ —Ä—ã–Ω–∫–∞
                    # ... (–æ—Å—Ç–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                    
                    # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–ª–µ—á–æ –¥–ª—è futures
                    if trading_type == 'futures':
                        pnl_percent = pnl_percent * leverage
                    
                    pnl = (current_price - entry_price) * qty
                    if position_side == 'SHORT':
                        pnl = -pnl
                    
                    # –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–ª–µ—á–æ, —É–º–Ω–æ–∂–∞–µ–º PnL –Ω–∞ –ø–ª–µ—á–æ
                    if trading_type == 'futures':
                        pnl = pnl * leverage
                    
                    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ –ú–°–ö
                    moscow_tz = pytz.timezone('Europe/Moscow')
                    now = dt.datetime.now(moscow_tz)
                    current_date = now.strftime('%d.%m.%Y')
                    current_time = now.strftime('%H:%M')
                    
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è –æ—Ä–¥–µ—Ä–∞ –∏–∑ UTC –≤ –ú–°–ö
                    open_time = None
                    if 'open_time' in order:
                        open_time = order['open_time']
                    elif 'buy_time' in order:
                        open_time = int(dt.datetime.timestamp(order['buy_time']))
                    else:
                        open_time = int(dt.datetime.now().timestamp())
                    
                    buy_time_utc = dt.datetime.fromtimestamp(open_time)
                    buy_time_moscow = pytz.utc.localize(buy_time_utc).astimezone(moscow_tz)
                    buy_date = buy_time_moscow.strftime('%d.%m.%Y')
                    buy_time = buy_time_moscow.strftime('%H:%M')
                    
                    # –ü–æ–ª—É—á–∞–µ–º —Å—É–º–º–∞—Ä–Ω—ã–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å
                    daily_profit = await get_daily_profit(user_id, now.date())
                    
                    # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å –ø–æ—Å–ª–µ –≤–æ–∑–≤—Ä–∞—Ç–∞ —Å—Ä–µ–¥—Å—Ç–≤
                    new_balance = await get_user_balance(user_id)
                    
                    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞
                    balance_change = new_balance - current_balance
                    print(f"–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –æ—Ä–¥–µ—Ä–∞: {new_balance} (–∏–∑–º–µ–Ω–µ–Ω–∏–µ: {balance_change})")
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∏–º–≤–æ–ª
                    direction = "Long üî∞" if position_side == 'LONG' else "Short üîª"
                    symbol = order.get('symbol', 'UNKNOWN')
                    symbol_base = symbol.replace('USDT', '')
                    timeframe = order.get('timeframe', order.get('interval', '1h'))
                    
                    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∏—á–∏–Ω—ã –∑–∞–∫—Ä—ã—Ç–∏—è
                    if close_reason == "TP":
                        message = (
                            f"üî¥ <b>–ó–ê–ö–†–´–¢–ò–ï –û–†–î–ï–†–ê</b> {symbol} {timeframe}\n\n"
                            f"–ë–∏—Ä–∂–∞: {order.get('exchange', 'Bybit')}\n"
                            f"–¢–∏–ø —Ç–æ—Ä–≥–æ–≤–ª–∏: {order.get('trading_type', 'spot').upper()}"
                            f"{' | –ü–ª–µ—á–æ: x' + str(order.get('leverage', 1)) if order.get('trading_type') == 'futures' else ''}\n\n"
                            f"üéØ‚úÖ –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¢–µ–π–∫-–ü—Ä–æ—Ñ–∏—Ç\n"
                            f"üí∏üîã–ü—Ä–∏–±—ã–ª—å –ø–æ —Å–¥–µ–ª–∫–µ: {pnl_percent:.2f}% ({pnl:.2f} USDT)\n\n"
                            f"‚ôªÔ∏è–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞: {entry_price:.2f}$\n"
                            f"üìà–¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏: {current_price:.4f}$\n"
                            f"üõë–ü—Ä–æ–¥–∞–Ω–æ: {qty:.6f} {symbol_base} ({(qty * current_price):.2f} USDT)\n\n"
                            f"üìÜ–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞: {buy_date}\n"
                            f"üïê–í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è: {buy_time} –ú—Å–∫\n"
                            f"üìâ–¢–§ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏: {timeframe}\n"
                            f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {direction}\n\n"
                            f"–û–±—â–∏–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å: {'+' if daily_profit > 0 else ''} {daily_profit:.2f} USDT {'üí∏üîã' if daily_profit > 0 else 'ü§ï'}\n"
                            f"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance:.2f} USDT"
                        )
                    else:  # SL
                        message = (
                            f"üî¥ <b>–ó–ê–ö–†–´–¢–ò–ï –û–†–î–ï–†–ê</b> {symbol} {timeframe}\n\n"
                            f"–ë–∏—Ä–∂–∞: {order.get('exchange', 'Bybit')}\n"
                            f"–¢–∏–ø —Ç–æ—Ä–≥–æ–≤–ª–∏: {order.get('trading_type', 'spot').upper()}"
                            f"{' | –ü–ª–µ—á–æ: x' + str(order.get('leverage', 1)) if order.get('trading_type') == 'futures' else ''}\n\n"
                            f"üìõ–ó–∞–∫—Ä—ã—Ç–æ –ø–æ –°—Ç–æ–ø-–ª–æ—Å—Å—É\n"
                            f"ü§ïü™´–£–±—ã—Ç–æ–∫ –ø–æ —Å–¥–µ–ª–∫–µ: {pnl_percent:.2f}% ({pnl:.2f} USDT)\n\n"
                            f"‚ôªÔ∏è–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞: {entry_price:.2f}$\n"
                            f"üìà–¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏: {current_price:.4f}$\n"
                            f"üõë–ü—Ä–æ–¥–∞–Ω–æ: {qty:.6f} {symbol_base} ({(qty * current_price):.2f} USDT)\n\n"
                            f"üìÜ–°–¥–µ–ª–∫–∞ –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞: {buy_date}\n"
                            f"üïê–í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è: {buy_time} –ú—Å–∫\n"
                            f"üìâ–¢–§ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏: {timeframe}\n"
                            f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {direction}\n\n"
                            f"–û–±—â–∏–π –ø—Ä–æ—Ñ–∏—Ç –∑–∞ –¥–µ–Ω—å: {'+' if daily_profit > 0 else ''} {daily_profit:.2f} USDT {'üí∏üîã' if daily_profit > 0 else 'ü§ï'}\n"
                            f"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance:.2f} USDT"
                        )
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                    await bot.send_message(user_id, message)
                    
                    return True
                except Exception as e:
                    print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ—Ä–¥–µ—Ä–∞: {e}")
                    await bot.send_message(user_id, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ—Ä–¥–µ—Ä–∞: {e}")
                    return False
                
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–π –¥–ª—è –≤—Å–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ process_tf
        except Exception as e:
            print(f"Error in internal_trade_logic: {e}")
            await asyncio.sleep(0.05)  # –Ω–µ –¥—É—à–∏–º API

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤."""
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    await init_db()
    
    # –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–∂–¥–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
    tasks = []
    for tf in TIMEFRAMES:
        tasks.append(asyncio.create_task(process_tf(tf)))
    
    # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
    await asyncio.gather(*tasks)

# –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
if __name__ == "__main__":
    asyncio.run(main())
